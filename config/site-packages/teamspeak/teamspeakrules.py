# TeamSpeak Third Party Ruleset - This helps us to intercept, change or even block Matrix events for our purpose.
# https://matrix-org.github.io/synapse/v1.54/modules/third_party_rules_callbacks.html

from typing import Dict, Optional, Sequence, Tuple, Union
from synapse.events import DictProperty, EventBase
from synapse.events.snapshot import EventContext
# from synapse.handlers.space_summary import SpaceSummaryHandler
from synapse.module_api import ModuleApi
from synapse.server import HomeServer
from synapse.storage import DataStore
from synapse.storage.state import StateFilter
from synapse.storage.databases.main.directory import RoomAliasMapping
from synapse.types import JsonDict, Requester, RoomAlias, StateMap, UserID
from synapse.api.errors import SynapseError, Codes
import re
import uuid
import base64

# TODO: Read from config. Niels-> I am fine with these being constants
ADMIN_SPACE_ALIAS = "ts_admin_root"
ADMIN_STATE_EVENT = "com.teamspeak.homebase_users"
VIRTUAL_SERVER_STATE_EVENT = "com.teamspeak.virtual_server"
APP_SERVICE_USER ="teamspeak.server"
#SERVER_ROOM_NAME_TEMPLATE = "ts_admin_db_server_{}"

def is_valid_uuid(val):
    try:
        return uuid.UUID(str(val))
    except ValueError:
        return None

class TeamSpeakRuleset(object):

    # Caches room_ids resolved by room_alias
    _room_alias_id_cache: Dict[str, str] = {}

    # Caches virtual server rooms resolved via space
    _server_id_room_id_cache: Dict[str, str] = {}

    # Caches app_server user id
    _app_server_user_id = ""

    def __init__(self, config: Dict, api: ModuleApi):
        self.module_api = api
        self.config = config
        print("### TeamSpeakRuleset ctor", config)


        # check_event_for_spam does not do what we need.
        # see note on function below
        #
        # self.module_api.register_spam_checker_callbacks(
        #     check_event_for_spam = self.check_event_for_spam,
        # )

        self.module_api.register_third_party_rules_callbacks(
            on_create_room=self.on_create_room,
            check_event_allowed=self.check_event_allowed,
        )
    # Overrides

    async def on_create_room(
        self,
        requester: "Requester",
        request_content: dict,
        is_requester_admin: bool,
        ) -> None:

        print("###  on create room", requester, is_requester_admin)

        # Always allow admin users
        if is_requester_admin == True:
            print("### is admin, allow")
            return True

        # Always allow app server user
        user_id = requester.user.to_string()        
        if self._is_app_server(user_id):
            print("### is appserver, allow")
            return True

        # For non-admin users, only allow if user has homebase on this server
        is_home_base_user = await self._is_home_base_user(user_id)

        print("### is_home_base_user:", is_home_base_user)
        if not is_home_base_user:
            raise SynapseError(code=403, msg="You are not permitted to create rooms", errcode=Codes.FORBIDDEN)

        return True

    # Note that check_event_for_spam does not get called for room joins. Although the synapse modules documentation
    # recommends to use the check_event_for_spam implying the api is more stable, we can not actually use this
    #
    # async def check_event_for_spam(self, event: EventBase) -> Union[bool, str]:
    #     if not await self._check_event_allowed(event):
    #         return "action not allowed because of custom TeamSpeak rules"
    #     return False


    async def check_event_allowed(
        self,
        event: EventBase,
        state_events: StateMap,
        ) -> Tuple[bool, Optional[dict]]:
        return await self._check_event_allowed(event), None


    # Private


    async def _check_event_allowed(self, event: EventBase)-> bool:

        print("### check_event_allowed", event)

        # Always allow events from app server
        if self._is_app_server(event.sender):
            return True

        if event.type == "m.room.member":

            #get the virtual servers (and channels) for which this room is a type I chat room
            room_type_I_vs_to_channel_map, room_private_chat_map = await self._get_alias_info(event)

            #if this is a teamspeak user, split its name to a vs and domain
            (user_id, user_vs, user_domain) = self._split_user(event.sender)

            print("### member event")
            membership = event.content["membership"]
            print("### membership", membership)

            if membership == "join":
                print("### Checking JOIN")
                sender = event.sender
                print("### sender", sender)

                # For type I rooms, allow anyone from this server but disallow anyone from another matrix server
                if room_type_I_vs_to_channel_map:
                    print("### Joining type I room, always allowed")
                    return user_domain == self._servername() and user_vs in room_type_I_vs_to_channel_map

                # For private chat rooms, allow anyone from this server but disallow anyone from another matrix server
                if room_private_chat_map:
                    print("### Joining private chat room, allowed user is a participant")
                    return user_domain == self._servername() and user_id in room_private_chat_map.get(user_vs,[])

                # For type II and III rooms, user needs to be a homebase user if coming from this matrix server, but allow anyone from another matrix server
                if user_domain != self._servername():
                    return True

                return await self._is_home_base_user_on_vs(sender, user_vs)

            elif membership == "invite":
                print("### Checking INVITE")
                sender = event.sender
                print("### sender", sender)

                # Disallow any invites to type I rooms if not coming from app server.
                # Note: room powerlevels for type I rooms *should* be such that only app server can invite
                #       but it does not hurt to check here too.
                if room_type_I_vs_to_channel_map:
                    return False
                # For type II and III users, allow sender and receiver from this server only if homebase user and always from other matrix servers
                if user_domain == self._servername() and not await self._is_home_base_user_on_vs(event.sender, user_vs):
                    return False

                receiver = event.state_key
                print("### receiver", receiver)
                (_, receiver_vs, receiver_domain) = self._split_user(event.state_key)

                if receiver_domain == self._servername() and not await self._is_home_base_user_on_vs(event.state_key, receiver_vs):
                    return False

                return True

        #allow all other events regardless
        return True


    def _homeserver(self) -> HomeServer:
        return self.module_api._hs


    def _store(self) -> DataStore:
        return self.module_api._store


    def _servername(self) -> str:

        """
            returns the server/domain name of this synapse instance
        """

        return self.module_api._server_name


    def _is_app_server(self, user_id: str) -> bool:

        """
            returns True of the user_id is the teamspeak app server for synapse
        """

        return user_id == self._get_app_server_user_id()


    def _get_app_server_user_id(self) -> str:

        """
            returns the userid of the teamspeak app server
        """

        if not self._app_server_user_id:
            self._app_server_user_id = "@{}:{}".format(APP_SERVICE_USER, self._servername())
        return self._app_server_user_id


    async def _is_home_base_user(self, user_id: str) -> bool:

        """
            returns if user_id is a homebase user for the vs which is encoded in the user_id
        """

        (_, user_vs, user_domain) = self._split_user(user_id)
        return user_domain==self._servername() and await self._is_home_base_user_on_vs(user_id, user_vs)


    async def _is_home_base_user_on_vs(self, userid: str, vs_uuid: str ) -> bool:

        """
            returns if specified user_id is homebase user on vs_uuid
        """
        if vs_uuid is None:
            return False

        home_base_users = await self._get_homebase_users(vs_uuid)

        if not home_base_users:
            print("### home base users not found")
            return False

        print("### home_base_users", home_base_users)
        return userid in home_base_users


    def _get_room_canonical_alias(self, state_events : EventContext) -> Union[None, EventBase]:

        """
            returns the conanical alias event, or None if there was none in the given state_events
        """

        if ("m.room.canonical_alias", "") not in state_events:
                return None

        return state_events[("m.room.canonical_alias", "")]


    def _split_type_I_room_alias(self, alias: str) -> Tuple[str, str, str]:

        """
            splits a room alias into the virtual server guid, channel guid and matrix domain,
            if the room alias is of type I. Returns None, None, None otherwise
        """

        room_re = re.compile(r"^#ts_local_([a-z0-9]{8}-([a-z0-9]{4}-){3}[a-z0-9]{12})_([a-z0-9]{8}-([a-z0-9]{4}-){3}[a-z0-9]{12}):(.*)$")
        m = room_re.match(alias)

        if m is None:
            return None, None, None

        return m.group(1), m.group(3), m.group(5)


    def _split_private_chat_room_alias(self, alias: str) -> Tuple[str, Sequence[str], str]:

        """
            splits a room alias into the virtual server guid, users id in hex list and matrix domain,
            if the room alias is a private chat. Returns None, None, None otherwise
        """

        room_re = re.compile(r"^#ts_local_private_([a-z0-9]{8}-([a-z0-9]{4}-){3}[a-z0-9]{12})_([a-zA-Z0-9+/=]+)_([a-zA-Z0-9+/=]+):(.*)$")
        m = room_re.match(alias)

        try:
            usr1 = base64.b64decode(m.group(3).encode('ascii')).hex()
            usr2 = base64.b64decode(m.group(4).encode('ascii')).hex()
            return m.group(1), [usr1, usr2], m.group(5)
        except:
            return None, None, None



    def _split_user(self, user) -> Tuple[str, str, str]:

        """
            splits a user id into user unique id in hex str, virtual server uuid, domain
        """

        user_re = re.compile(r"^@ts_([a-f0-9]{40})_([a-z0-9]{8}-([a-z0-9]{4}-){3}[a-z0-9]{12}):(.*)$")
        m = user_re.match(user)

        if m is None:
            return None, None, None

        return m.group(1), m.group(2), m.group(4)


    def _get_type_I_alias_info(self, aliases: Sequence[str]) -> Dict[str, Sequence[str]]:

        """
            returns a map of virtualservers uuid to array of channels uuids for the given
            event's room
        """

        split_aliases = [self._split_type_I_room_alias(x) for x in aliases]
        type_I_tuples = [(vs, chan) for (vs, chan, dom) in split_aliases if dom == self.module_api._server_name]
        unique_vs = list(set([vs for (vs, _,) in type_I_tuples]))
        return {vs: [chan for (vsl, chan) in type_I_tuples if vsl == vs] for vs in unique_vs}


    def _get_private_chat_alias_info(self, aliases: Sequence[str]) -> Dict[str, Sequence[str]]:

        """
            returns a map of virtualservers uuid to list of list of chat users
        """

        split_aliases = [self._split_private_chat_room_alias(x) for x in aliases]
        tuples = [(vs, users) for (vs, users, dom) in split_aliases if dom == self.module_api._server_name]
        unique_vs = list(set([vs for (vs, _,) in tuples]))
        return {vs: [u for (vsl, users) in tuples if vsl == vs for u in users] for vs in unique_vs}


    async def _get_alias_info(self, event: EventBase) -> Tuple[Dict[str, Sequence[str]], Dict[str, Sequence[str]]]:

        """
            returns a tuple Type I info, private chat info
        """

        aliases = await self._store().get_aliases_for_room(event.room_id)
        return (self._get_type_I_alias_info(aliases), self._get_private_chat_alias_info(aliases))

    async def _get_homebase_users(self, server_id: str) -> Sequence[str]:

        """
          get homebase users from vs admin room
        """

        admin_room_id = await self._get_admin_room_id(server_id)
        print("### admin_room_id", admin_room_id)

        if not admin_room_id:
            return []

        # Get the admin event content from the admin room
        admin_event = await self._get_admin_state_event(admin_room_id)
        print("### admin_event", admin_event)
        if not admin_event:
            return []

        # Read home base users from admin event content
        try:
            return admin_event["home_base_users"]
        except KeyError:
            print("### home_base_users not found in admin event")
            return []


    async def _resolve_room_id(self, room_alias: str) -> str:

        try:
            room_id = self._room_alias_id_cache[room_alias]  # Cache hit
            print("### room_alias to room_id cache hit:", room_alias, room_id)
            return room_id

        except KeyError:
            print("### room_alias to room_id cache miss:", room_alias)
            pass  # Cache miss

        print("### looking up admin room id")
        ra = RoomAlias(room_alias, self._servername())
        r: RoomAliasMapping = await self._store().get_association_from_room_alias(ra)

        if not r:
            return None

        self._room_alias_id_cache[room_alias] = r.room_id  # Cache it
        return r.room_id

    async def _get_admin_room_id(self, server_id: str) -> str:

        try:
            room_id = self._server_id_room_id_cache[server_id]  # Cache hit
            print("### server_id to room_id cache hit:", server_id, room_id)
            return room_id

        except KeyError:
            print("### server_id to room_id cache miss:", server_id)
            pass # Cache miss

        root_room_id = await self._resolve_room_id(ADMIN_SPACE_ALIAS)

        if not root_room_id:
            print("### root room id not resolved")
            return None

        print("### root_room_id", root_room_id)

        #if cache is empty, get all virtual servers, else just this one
        state_key_filter = None if len(self._server_id_room_id_cache) == 0 else server_id

        state_ids = await self._store().get_partial_filtered_current_state_ids(root_room_id, StateFilter.from_types([(VIRTUAL_SERVER_STATE_EVENT, state_key_filter)]))
        room_state_events = await self._store().get_events(state_ids.values())

        for key, event_id in state_ids.items():

            (event_type, state_key) = key
            if not (event_type == VIRTUAL_SERVER_STATE_EVENT and is_valid_uuid(state_key)):
                continue

            try:
                self._server_id_room_id_cache[server_id] = room_state_events[event_id].content['room_id']

            except KeyError:
                print("### bad content for server_id", state_key)

        try:
            return self._server_id_room_id_cache[server_id]

        except KeyError:
            return None


    async def _get_admin_state_event(self, room_id: str) -> DictProperty:

        if not room_id:
            return None

        state_ids = await self._store().get_partial_filtered_current_state_ids(room_id, StateFilter.from_types([(ADMIN_STATE_EVENT, "")]))
        print("### state_ids", state_ids)

        if not state_ids:
            print("### no state events found")
            return None

        try:
            event_id = state_ids[(ADMIN_STATE_EVENT, "")]
            print("### event_id", event_id)
            events = await self._store().get_events(event_ids=[event_id])
            print("### events", events)
            admin_event = events[event_id]
            print("### admin_event", admin_event.content)
            return admin_event.content

        except KeyError:
            return None

    @staticmethod
    def parse_config(config):
        return config
